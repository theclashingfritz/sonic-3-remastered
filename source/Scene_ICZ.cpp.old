#include "Standard.h"
#include "Scene_MainMenu.h"
#include "Application.h"
#include "Resources.h"
#include "Player.h"
#include "Scene_ICZ.h"
#include "S3Object.h"
#include "LevelScene.h"

#define WITH_ALL(IN) for (int _______p = 0; _______p < player_count; _______p++) { \
	Player* player = playerBuffer[_______p]; \
	IN \
}

void Scene_ICZ::LoadLayoutRW(void* data) {
	LevelScene* scene 	= ((ThreadLoader*)data)->scene;
	int act 			= ((ThreadLoader*)data)->act;

	if ((act & 0xF) == 1) {
		SDL_RWops* rw = newFile(res_ICZ_layout_1_bin, "res/ICZ/layout/1.bin");
		SDL_RWread(rw, scene->levelBuffer, sizeof(unsigned char) * (size_t)SDL_RWsize(rw), 1);
		SDL_RWclose(rw); rw = NULL;

		rw = newFile(res_ICZ_chunks_1_bin, "res/ICZ/chunks/1.bin");
		SDL_RWread(rw, scene->chunksBuffer, sizeof(unsigned char) * (size_t)SDL_RWsize(rw), 1);
		SDL_RWclose(rw); rw = NULL;

		rw = newFile(res_ICZ_chunks_1_bin, "res/ICZ/tiles/1.bin");
		SDL_RWread(rw, scene->tiles, sizeof(unsigned char) * (size_t)SDL_RWsize(rw), 1);
		SDL_RWclose(rw); rw = NULL;

		LevelScene::Ring cur = { -1, -1, false };
		rw = newFile(res_ICZ_rings_1_bin, "res/ICZ/rings/1.bin");
		for (int index = 0; index < SDL_RWsize(rw); index++) {
			unsigned char data;
			SDL_RWread(rw, &data, sizeof(unsigned char), 1);

			if (index % 4 == 0) {
				cur.X = (int)(data & 0xFF) * 0x100;
			}
			else if (index % 4 == 1) {
				cur.X += (int)(data & 0xFF);
			}
			else if (index % 4 == 2) {
				cur.Y = (int)(data & 0xFF) * 0x100;
			}
			else if (index % 4 == 3) {
				cur.Y += (int)(data & 0xFF);
				cur.Active = true;
				scene->ringArrBuffer[scene->ringTotal] = cur;
				scene->ringTotal++;
			}
		}
		SDL_RWclose(rw); rw = NULL;
	}
	else {
		SDL_RWops* rw = newFile(res_ICZ_layout_2_bin, "res/ICZ/layout/2.bin");
		for (int i = 0; i < SDL_RWsize(rw); i++) {
			SDL_RWread(rw, &scene->levelBuffer[i], sizeof(unsigned char), 1);
		}
		SDL_RWclose(rw); rw = NULL;

		rw = newFile(res_ICZ_chunks_2_bin, "res/ICZ/chunks/1.bin");
		for (int i = 0; i < SDL_RWsize(rw); i++) {
			SDL_RWread(rw, &scene->chunksBuffer[i], sizeof(unsigned char), 1);
		}
		SDL_RWclose(rw); rw = NULL;

		rw = newFile(res_ICZ_chunks_1_bin, "res/ICZ/tiles/2.bin");
		for (int i = 0; i < SDL_RWsize(rw); i++) {
			SDL_RWread(rw, &scene->tiles[i], sizeof(unsigned char), 1);
		}
		SDL_RWclose(rw); rw = NULL;

		LevelScene::Ring cur = { -1, -1, false };
		rw = newFile(res_ICZ_rings_2_bin, "res/ICZ/rings/2.bin");
		for (int index = 0; index < SDL_RWsize(rw); index++) {
			unsigned char data;
			SDL_RWread(rw, &data, sizeof(unsigned char), 1);

			if (index % 4 == 0) {
				cur.X = (int)(data & 0xFF) * 0x100;
			}
			else if (index % 4 == 1) {
				cur.X += (int)(data & 0xFF);
			}
			else if (index % 4 == 2) {
				cur.Y = (int)(data & 0xFF) * 0x100;
			}
			else if (index % 4 == 3) {
				cur.Y += (int)(data & 0xFF);
				cur.Active = true;
				scene->ringArrBuffer[scene->ringTotal] = cur;
				scene->ringTotal++;
			}
		}
		SDL_RWclose(rw); rw = NULL;
	}
}

Scene_ICZ::Scene_ICZ(Application* app, int act, int checkpoint) {
	//levelTextLine1 = "ICE CAP";
	levelTextLine2 = "ZONE";

	this->app = app;
	this->act = 0x50 + act;
	this->checkpoint = checkpoint;

	loop = true;

	beginActZoneTransfer(act);

	loadCommonTextures(app);

	unsigned int nextTick = SDL_GetTicks();
	unsigned int nextTickALL = nextTick;


	aud_BadnikDestroyed = newSound(snd_BadnikDestroyed_ogg, "snd/BadnikDestroyed.ogg");
	aud_BossHit = newSound(snd_BossHit_ogg, "snd/BossHit.ogg");
	aud_BreakDeeper = newSound(snd_BreakDeeper_ogg, "snd/BreakDeeper.ogg");
	aud_BubbleGet = newSound(snd_BubbleGet_ogg, "snd/BubbleGet.ogg");
	aud_Checkpoint = newSound(snd_Checkpoint_ogg, "snd/Checkpoint.ogg");
	aud_C_Drown = newSound(snd_C_Drown_ogg, "snd/C_Drown.ogg");
	aud_C_ShortBeep = newSound(snd_C_ShortBeep_ogg, "snd/C_ShortBeep.ogg");
	aud_C_RingLoss = newSound(snd_C_RingLoss_ogg, "snd/C_RingLoss.ogg");
	aud_Die = newSound(snd_Die_ogg, "snd/Die.ogg");
	aud_Jump = newSound(snd_Jump_ogg, "snd/Jump.ogg");
	aud_Ring = newSound(snd_Ring_ogg, "snd/Ring.ogg");
	aud_Roll = newSound(snd_Roll_ogg, "snd/Roll.ogg");
	aud_ShieldBounce = newSound(snd_ShieldBounce_ogg, "snd/ShieldBounce.ogg");
	aud_ShieldBubble = newSound(snd_ShieldBubble_ogg, "snd/ShieldBubble.ogg");
	aud_ShieldEJump = newSound(snd_ShieldEJump_ogg, "snd/ShieldEJump.ogg");
	aud_ShieldElectric = newSound(snd_ShieldElectric_ogg, "snd/ShieldElectric.ogg");
	aud_ShieldFire = newSound(snd_ShieldFire_ogg, "snd/ShieldFire.ogg");
	aud_Skid = newSound(snd_Skid_ogg, "snd/Skid.ogg");
	aud_Spiked = newSound(snd_Spiked_ogg, "snd/Spiked.ogg");
	aud_SpinRev = newSound(snd_SpinRev_ogg, "snd/SpinRev.ogg");
	aud_Spring = newSound(snd_Spring_ogg, "snd/Spring.ogg");

	app->print(0, "AUDIO (sound effects) load finished in %.3f seconds.", (SDL_GetTicks() - nextTick) / 1000.0f);
	nextTick = SDL_GetTicks();

	if (act == 1) {
		aud_BGM_HCZ1 = newMusic(snd_BGM_CNZ1_ogg, "snd/BGM_CNZ1.ogg");
	}
	else {
		aud_BGM_HCZ2 = newMusic(snd_BGM_CNZ2_ogg, "snd/BGM_CNZ2.ogg");
	}

	app->print(0, "AUDIO (musics) load finished in %.3f seconds.", (SDL_GetTicks() - nextTick) / 1000.0f);

	for (int i = 0; i < 60; i++) {
		inputBuffer[i] = false;
	}

	// General Physics Loads
	nextTick = SDL_GetTicks();
	SDL_RWops* rw = newFile(res_Common_LVL_Heights_bin, "res/Common/LVL_Heights.bin");
	for (int i = 0; i < SDL_RWsize(rw); i++) {
		SDL_RWread(rw, &heights[i], sizeof(unsigned char), 1);
	}
	SDL_RWclose(rw); rw = NULL;

	rw = newFile(res_Common_LVL_Angles_bin, "res/Common/LVL_Angles.bin");
	for (int i = 0; i < SDL_RWsize(rw); i++) {
		SDL_RWread(rw, &angles[i], sizeof(unsigned char), 1);
	}
	SDL_RWclose(rw); rw = NULL;
	app->print(0, "GENERAL (physics) load finished in %.3f seconds.", (SDL_GetTicks() - nextTick) / 1000.0f);

	tex_Sonic = newTexture(res_Common_Sonic_png, 13, 13, "res/Common/Sonic.png");
	tex_Tails = newTexture(res_Common_Tails_png, 13, 13, "res/Common/Tails.png");
	tex_Tails_Tails = newTexture(res_Common_Tails_Tails_png, 8, 6, "res/Common/Tails_Tails.png");

	InitZone(true, checkpoint, -1, false);

	app->print(0, "ALL LOADS finished in %.3f seconds.", (SDL_GetTicks() - nextTickALL) / 1000.0f);
}

void Scene_ICZ::LoadPalette() {
	if ((act & 0xF) == 1) {
		paletteDry = newPalTexture(res_ICZ_PAL1_DRY_png, 1, 1, "res/ICZ/PAL1_DRY.png");
		paletteWet = newPalTexture(res_ICZ_PAL1_WET_png, 1, 1, "res/ICZ/PAL1_WET.png");
	}
	else {
		paletteDry = newPalTexture(res_ICZ_PAL2_DRY_png, 1, 1, "res/ICZ/PAL1_DRY.png");
		paletteWet = newPalTexture(res_ICZ_PAL2_WET_png, 1, 1, "res/ICZ/PAL1_WET.png");
	}
	paletteBossDry = newPalTexture(res_HCZ_PALm_DRY_png, 1, 1, "res/HCZ/PALm_DRY.png");
	paletteBossWet = newPalTexture(res_HCZ_PALm_WET_png, 1, 1, "res/HCZ/PALm_WET.png");
}
void Scene_ICZ::createParallaxLayers() {
	// Parallax Layers
	if ((act & 0xF) == 1) {
		layers[0] = ParallaxLayer {  64, 32.0f / 128.0f };
		layers[1] = ParallaxLayer {   8, 48.0f / 220.0f };
		layers[2] = ParallaxLayer {   8, 32.0f / 172.0f };
		layers[3] = ParallaxLayer {   4, 24.0f / 152.0f };
		layers[4] = ParallaxLayer {   4, 16.0f / 152.0f };
		layers[5] = ParallaxLayer {   4,  8.0f /  88.0f };
		layers[6] = ParallaxLayer {  36, 64.0f / 960.0f };

		layers[7] = ParallaxLayer { 128, 64.0f / 960.0f };

		layers[8] = ParallaxLayer {  84, 64.0f / 960.0f };
		layers[9] = ParallaxLayer {   4,  8.0f /  88.0f };
		layers[10] = ParallaxLayer {  4, 16.0f / 152.0f };
		layers[11] = ParallaxLayer {  4, 24.0f / 152.0f };
		layers[12] = ParallaxLayer {  8, 32.0f / 172.0f };
		layers[13] = ParallaxLayer {  8, 48.0f / 220.0f };
		layers[14] = ParallaxLayer { 16, 32.0f / 128.0f };

		layers[15] = ParallaxLayer { 128, 32.0f / 128.0f };

		layers[16] = ParallaxLayer { 128, 32.0f / 128.0f };
		layers[17] = ParallaxLayer { 128, 32.0f / 128.0f };
		layers[18] = ParallaxLayer { 128, 32.0f / 128.0f };

		layerCount = 19;
	}
	else {
		layers[0] = ParallaxLayer {   8, 32.0f / 128.0f };
		layers[1] = ParallaxLayer {   8, 48.0f / 220.0f };
		layers[2] = ParallaxLayer { 112, 32.0f / 172.0f };

		layers[3] = ParallaxLayer {  32, 32.0f / 172.0f };
		layers[4] = ParallaxLayer {  16, 24.0f / 152.0f };

		layers[5] = ParallaxLayer {   8, 16.0f / 152.0f };
		layers[6] = ParallaxLayer {  48,  8.0f /  88.0f };
		layers[7] = ParallaxLayer {  24, 64.0f / 960.0f };

		layers[8] = ParallaxLayer {   8, 64.0f / 960.0f };
		layers[9] = ParallaxLayer {   8, 64.0f / 960.0f };
		layers[10] = ParallaxLayer { 112,  8.0f /  88.0f };

		layers[11] = ParallaxLayer {  56,  8.0f /  88.0f };
		layers[12] = ParallaxLayer {  48, 16.0f / 152.0f };
		layers[13] = ParallaxLayer {  24, 24.0f / 152.0f };

		layers[14] = ParallaxLayer {  8, 32.0f / 172.0f };
		layers[15] = ParallaxLayer {  8, 48.0f / 220.0f };
		layers[16] = ParallaxLayer { 112, 32.0f / 128.0f };

		layers[17] = ParallaxLayer { 128, 32.0f / 128.0f };

		layerCount = 18;
	}
}
void Scene_ICZ::LoadObjectData() {
	if ((act & 0xF) == 1) {
		SDL_RWops* rw = newFile(res_ICZ_objects_1_bin, "res/ICZ/objects/1.bin");
		for (objs_length = 0; objs_length < SDL_RWsize(rw); objs_length++) {
			SDL_RWread(rw, &objs[objs_length], sizeof(unsigned char), 1);
		}
		SDL_RWclose(rw); rw = NULL;

		waterLevel = 0xD * 128;
		visualWaterHeight = 0xD * 128;
	}
	else {
		SDL_RWops* rw = newFile(res_ICZ_objects_2_bin, "res/ICZ/objects/2.bin");
		for (objs_length = 0; objs_length < SDL_RWsize(rw); objs_length++) {
			SDL_RWread(rw, &objs[objs_length], sizeof(unsigned char), 1);
		}
		SDL_RWclose(rw); rw = NULL;

		levelSubW = 4;

		waterLevel = 0xE * 128;
		visualWaterHeight = 0xE * 128;
	}
}

void Scene_ICZ::DoSwitchActZone() {
	if (!doSwitch) return;

	doSwitch = false;

	WITH_ALL(
		player->x -= 0x3600;
		player->y  = 0x0830;
	)
	cameraX[app->CurrentViewport] -= 0x3600;
	cameraY[app->CurrentViewport] = 0x0830 - app->gameHeight / 2;
	cameraMinX = 0;
	cameraMinY = 0;

	this->act = 0x20 + (act & 0xF) + 1;

	InitZone(true, 0, -1, true);
}
void Scene_ICZ::InitZone(bool resetTextures, int check, int specialRing, bool actTransition) {
	actMusics[0] = aud_BGM_HCZ1;
	actMusics[1] = aud_BGM_HCZ2;

	sonStartPos[0] = 0x00180600;
	sonStartPos[1] = 0x02C006B0;
	knuStartPos[0] = 0x00100BAC;
	knuStartPos[1] = 0x02C006B0;

	animCount = 0;

	LevelScene::InitZone(resetTextures, check, specialRing, actTransition);
}

void Scene_ICZ::loadUniqueTextures(Application* app, int act) {
	if (act == 1) {
        loadingSpace[13] = newFile(res_ICZ_ChunksBack16x16_png, "res/ICZ/TILES1.png");
        loadingSpace[14] = newFile(res_ICZ_ChunksFront16x16_png, "res/ICZ/TILES1.png");
        loadingSpace[26] = newFile(res_ICZ_NonAnim1_5_png, "res/HCZ/NonAnim1_5.png");
    }
    else {
        loadingSpace[11] = newFile(res_ICZ_ChunksBack16x16_png, "res/ICZ/TILES1.png");
        loadingSpace[12] = newFile(res_ICZ_ChunksFront16x16_png, "res/ICZ/TILES1.png");
        loadingSpace[27] = newFile(res_ICZ_NonAnim2_5_png, "res/HCZ/NonAnim2_5.png");
    }
    loadingSpace[0] = newFile(res_ICZ_Blastoid4_png, "res/HCZ/Blastoid4.png");
    loadingSpace[1] = newFile(res_ICZ_Block_png, "res/HCZ/Block.png");
    loadingSpace[2] = newFile(res_ICZ_BossEffects41_png, "res/HCZ/BossEffects41.png");
    loadingSpace[3] = newFile(res_ICZ_BossExtra8_png, "res/HCZ/BossExtra8.png");
    loadingSpace[4] = newFile(res_ICZ_BreakableBar1x3_png, "res/HCZ/BreakableBar1x3.png");
    loadingSpace[5] = newFile(res_ICZ_BreakablePlatforms8x2_png, "res/HCZ/BreakablePlatforms8x2.png");
    loadingSpace[6] = newFile(res_ICZ_Bridge_png, "res/HCZ/Bridge.png");
    loadingSpace[7] = newFile(res_ICZ_Bubble8x2_png, "res/HCZ/Bubble8x2.png");
    loadingSpace[8] = newFile(res_ICZ_Bubbler3_png, "res/HCZ/Bubbler3.png");
    loadingSpace[9] = newFile(res_ICZ_Buggernaut6_png, "res/HCZ/Buggernaut6.png");
    loadingSpace[10] = newFile(res_ICZ_Button3_png, "res/HCZ/Button3.png");
    loadingSpace[15] = newFile(res_CNZ_Fan5x1_png, "res/HCZ/Fan5x1.png");
    loadingSpace[16] = newFile(res_ICZ_FloatingPlatform_png, "res/HCZ/FloatingPlatform.png");
    loadingSpace[17] = newFile(res_ICZ_Geyser_png, "res/HCZ/Geyser.png");
    loadingSpace[18] = newFile(res_ICZ_GeyserParticles1_8_png, "res/HCZ/GeyserParticles1_8.png");
    loadingSpace[19] = newFile(res_ICZ_GeyserParticles2_2_png, "res/HCZ/GeyserParticles2_2.png");
    loadingSpace[20] = newFile(res_ICZ_HandLauncher8_png, "res/HCZ/HandLauncher8.png");
    loadingSpace[21] = newFile(res_ICZ_Jawz2_png, "res/HCZ/Jawz2.png");
    loadingSpace[22] = newFile(res_ICZ_LargeFan5_png, "res/HCZ/LargeFan5.png");
    loadingSpace[23] = newFile(res_HCZ_MegaChopper4_png, "res/HCZ/MegaChopper4.png");
    loadingSpace[24] = newFile(res_HCZ_Miniboss8x3_png, "res/HCZ/Miniboss8x3.png");
    loadingSpace[25] = newFile(res_HCZ_MinibossPole3_png, "res/HCZ/MinibossPole3.png");
    loadingSpace[28] = newFile(res_ICZ_Pointdexter3_png, "res/HCZ/Pointdexter3.png");
    loadingSpace[29] = newFile(res_ICZ_SpinningColumn3_png, "res/HCZ/SpinningColumn3.png");
    loadingSpace[30] = newFile(res_ICZ_StarpostWater5_png, "res/HCZ/StarpostWater5.png");
    loadingSpace[31] = newFile(res_ICZ_TurboSpiker8x2_png, "res/HCZ/TurboSpiker8x2.png");
    loadingSpace[32] = newFile(res_ICZ_WaterDrop6_png, "res/HCZ/WaterDrop6.png");
    loadingSpace[33] = newFile(res_ICZ_WaterlineTop_png, "res/HCZ/WaterlineTop.png");
    loadingSpace[34] = newFile(res_ICZ_WaterRush4_png, "res/HCZ/WaterRush4.png");
    loadingSpace[35] = newFile(res_ICZ_Waves3_png, "res/HCZ/Waves3.png");

	//app->print(0, "UNIQUE Texture Load Finished in %.3f seconds", (SDL_GetTicks() - nextTick) / 1000.0f);
}
void Scene_ICZ::CreateUniqueTextures(Application* app, int act) {
	unsigned int nextTick = SDL_GetTicks();

	if (act == 1) {
        //tex_ChunksBack = new Texture(app, loadingSpace[13], 16, 16);
        tex_ChunksFront = new Texture(app, loadingSpace[14], 16, 16);
        tex_NonAnim_ = new Texture(app, loadingSpace[26], 5, 1);
    }
    else {
        //tex_ChunksBack = new Texture(app, loadingSpace[11], 16, 16);
        tex_ChunksFront = new Texture(app, loadingSpace[12], 16, 16);
        tex_NonAnim_ = new Texture(app, loadingSpace[27], 5, 1);
    }

    tex_Blastoid = new Texture(app, loadingSpace[0], 4, 1);
    tex_Block = new Texture(app, loadingSpace[1], 1, 1);
    tex_BossEffects = new Texture(app, loadingSpace[2], 41, 1);
    tex_BossExtra = new Texture(app, loadingSpace[3], 8, 1);
    tex_BreakableBar = new Texture(app, loadingSpace[4], 1, 3);
    tex_BreakablePlatforms = new Texture(app, loadingSpace[5], 8, 2);
    tex_Bridge = new Texture(app, loadingSpace[6], 1, 1);
    tex_Bubble = new Texture(app, loadingSpace[7], 8, 2);
    tex_Bubbler = new Texture(app, loadingSpace[8], 3, 1);
    tex_Buggernaut = new Texture(app, loadingSpace[9], 6, 1);
    tex_Button = new Texture(app, loadingSpace[10], 3, 1);
    tex_Fan = new Texture(app, loadingSpace[15], 5, 1);
    tex_FloatingPlatform = new Texture(app, loadingSpace[16], 1, 1);
    tex_Geyser = new Texture(app, loadingSpace[17], 1, 1);
    tex_GeyserParticles1_ = new Texture(app, loadingSpace[18], 8, 1);
    tex_GeyserParticles2_ = new Texture(app, loadingSpace[19], 2, 1);
    tex_HandLauncher = new Texture(app, loadingSpace[20], 8, 1);
    tex_Jawz = new Texture(app, loadingSpace[21], 2, 1);
    tex_LargeFan = new Texture(app, loadingSpace[22], 5, 1);
    tex_MegaChopper = new Texture(app, loadingSpace[23], 4, 1);
    tex_Miniboss = new Texture(app, loadingSpace[24], 8, 3);
    tex_MinibossPole = new Texture(app, loadingSpace[25], 3, 1);
    tex_Pointdexter = new Texture(app, loadingSpace[28], 3, 1);
    tex_SpinningColumn = new Texture(app, loadingSpace[29], 3, 1);
    tex_StarpostWater = new Texture(app, loadingSpace[30], 5, 1);
    tex_TurboSpiker = new Texture(app, loadingSpace[31], 8, 2);
    tex_WaterDrop = new Texture(app, loadingSpace[32], 6, 1);
    tex_WaterlineTop = new Texture(app, loadingSpace[33], 1, 1);
    tex_WaterRush = new Texture(app, loadingSpace[34], 4, 1);
    tex_Waves = new Texture(app, loadingSpace[35], 3, 1);

	app->print(0, "UNIQUE Texture load finished in %.3f seconds.", (SDL_GetTicks() - nextTick) / 1000.0f);
}
void Scene_ICZ::UnloadUniqueTextures(Application* app, int act) {
	if (act == 1) {
		if (tex_ChunksBack != NULL) tex_ChunksBack->Free(); tex_ChunksBack = NULL;
		if (tex_ChunksFront != NULL) tex_ChunksFront->Free(); tex_ChunksFront = NULL;
	}
	else {
		if (tex_Blastoid != NULL) tex_Blastoid->Free(); tex_Blastoid = NULL;
	    if (tex_Block != NULL) tex_Block->Free(); tex_Block = NULL;
	    if (tex_BossEffects != NULL) tex_BossEffects->Free(); tex_BossEffects = NULL;
	    if (tex_BossExtra != NULL) tex_BossExtra->Free(); tex_BossExtra = NULL;
	    if (tex_BreakableBar != NULL) tex_BreakableBar->Free(); tex_BreakableBar = NULL;
	    if (tex_BreakablePlatforms != NULL) tex_BreakablePlatforms->Free(); tex_BreakablePlatforms = NULL;
	    if (tex_Bridge != NULL) tex_Bridge->Free(); tex_Bridge = NULL;
	    if (tex_Bubble != NULL) tex_Bubble->Free(); tex_Bubble = NULL;
	    if (tex_Bubbler != NULL) tex_Bubbler->Free(); tex_Bubbler = NULL;
	    if (tex_Buggernaut != NULL) tex_Buggernaut->Free(); tex_Buggernaut = NULL;
	    if (tex_Button != NULL) tex_Button->Free(); tex_Button = NULL;

		if (tex_ChunksBack != NULL) tex_ChunksBack->Free(); tex_ChunksBack = NULL;
	    if (tex_ChunksFront != NULL) tex_ChunksFront->Free(); tex_ChunksFront = NULL;

		if (tex_Fan != NULL) tex_Fan->Free(); tex_Fan = NULL;
	    if (tex_FloatingPlatform != NULL) tex_FloatingPlatform->Free(); tex_FloatingPlatform = NULL;
	    if (tex_Geyser != NULL) tex_Geyser->Free(); tex_Geyser = NULL;
	    if (tex_GeyserParticles1_ != NULL) tex_GeyserParticles1_->Free(); tex_GeyserParticles1_ = NULL;
	    if (tex_GeyserParticles2_ != NULL) tex_GeyserParticles2_->Free(); tex_GeyserParticles2_ = NULL;
	    if (tex_HandLauncher != NULL) tex_HandLauncher->Free(); tex_HandLauncher = NULL;
	    if (tex_Jawz != NULL) tex_Jawz->Free(); tex_Jawz = NULL;
	    if (tex_LargeFan != NULL) tex_LargeFan->Free(); tex_LargeFan = NULL;
	    if (tex_MegaChopper != NULL) tex_MegaChopper->Free(); tex_MegaChopper = NULL;
	    if (tex_Miniboss != NULL) tex_Miniboss->Free(); tex_Miniboss = NULL;
	    if (tex_MinibossPole != NULL) tex_MinibossPole->Free(); tex_MinibossPole = NULL;
	    if (tex_NonAnim_ != NULL) tex_NonAnim_->Free(); tex_NonAnim_ = NULL;
	    if (tex_Pointdexter != NULL) tex_Pointdexter->Free(); tex_Pointdexter = NULL;
	    if (tex_SpinningColumn != NULL) tex_SpinningColumn->Free(); tex_SpinningColumn = NULL;
	    if (tex_StarpostWater != NULL) tex_StarpostWater->Free(); tex_StarpostWater = NULL;
	    if (tex_TurboSpiker != NULL) tex_TurboSpiker->Free(); tex_TurboSpiker = NULL;
	    if (tex_WaterDrop != NULL) tex_WaterDrop->Free(); tex_WaterDrop = NULL;
	    if (tex_WaterlineTop != NULL) tex_WaterlineTop->Free(); tex_WaterlineTop = NULL;
	    if (tex_WaterRush != NULL) tex_WaterRush->Free(); tex_WaterRush = NULL;
	    if (tex_Waves != NULL) tex_Waves->Free(); tex_Waves = NULL;
	}
}
void Scene_ICZ::LoadMusicAndSounds(Application* app, int act) {
	if (act != 1) { // Flipped so we can load the other on the back
		aud_BGM_HCZ1 = newMusic(snd_BGM_CNZ1_ogg, "snd/BGM_CNZ1.ogg");
	}
	else {
		aud_BGM_HCZ2 = newMusic(snd_BGM_CNZ2_ogg, "snd/BGM_CNZ2.ogg");
	}

	aud_BGM_LifeGet = newMusic2(snd_BGM_LifeGet_ogg, "snd/BGM_LifeGet.ogg");
	aud_BGM_Invincibility = newMusic2(snd_BGM_Invincibility_ogg, "snd/BGM_Invincibility.ogg");

	aud_BGM_Boss1 = newMusic(snd_BGM_Boss1_ogg, "snd/BGM_Boss1.ogg");
	aud_BGM_Drowning = newMusic2(snd_BGM_Drowning_ogg, "snd/BGM_Drowning.ogg");
}

void Scene_ICZ::Update() {
	if (app->platform == Application::P_iOS || app->platform == Application::P_Android) {
		float FullscreenOffset = getFullscreenOffset();
		for (int i = 0; i < 4; i++) {
			if (app->input->touchPressed[i]) {
				int X2 = app->gameWidth - FullscreenOffset - 76;
				int Y2 = 18;

				int X3 = app->input->touchX[i];
				int Y3 = app->input->touchY[i];

				float len = std::sqrt((Y2 - Y3) * (Y2 - Y3) + (X3 - X2) * (X3 - X2));

				if (len < 100) {
					app->realPaused = !app->realPaused;
				}
			}
		}
	}

	if (app->realPaused) {
		if (!app->soundPaused) {
			mainTrack->Pause();
			for (int i = 0; i < 8; i++) {
				Mix_Pause(i);
			}
			app->soundPaused = true;
		}
	}
	else {
		if (app->soundPaused) {
			mainTrack->Resume();
			for (int i = 0; i < 8; i++) {
				Mix_Resume(i);
			}
			app->soundPaused = false;
		}
	}

	if (app->realPaused) return;

	if (sceneIn > -2) {
		sceneIn -= 1;
		//WITH_ALL(
			//player->Controllable = false;
		//);
	}
	else if (sceneIn == -2) {
		player->Controllable = true;
	}
	if (sceneIn <= -2 || actTransition) {
		frame++;
		if (!levelComplete)
			frameTimer++;
	}
	frameAnim++;

	WITH_ALL(
		if (loop) {
			while (player->y > levelH * 128) {
				player->y -= levelH * 128;
			}
			while (player->y < 0) {
				player->y += levelH * 128;
			}
		}

		if (player->y > waterLevel) {
			if (!player->Underwater) {
				player->Underwater = true;
				player->Gravity *= 0.25f;
				player->Speed *= 0.5f;
				if (player->Shield == 1 || player->Shield == 2)
					player->Shield = 0;
				if (player->Action == Actions::Fly) {
					// audio_stop "flying sound"
				}

				particles[part_next++ % part_max] = new Particle(tex_Effect_WaterSplash, player->x, (float)waterLevel - 16, 10 * 4, 8 * 4, 4, true);
				app->input->Vibrate(0, 0.25, 150);
			}
		}
		else if (player->Underwater) {
			player->Underwater = false;
			player->Gravity += 0.0625f;
			//player->Gravity *= 2.0f;
			if (player->Shield == 1 || player->Shield == 2)
				player->Shield = 0;
			if (player->Action == Actions::Fly) {
				// audio_play "flying sound"
			}


			particles[part_next++ % 32] = new Particle(tex_Effect_WaterSplash, player->x, (float)waterLevel - 16, 10 * 4, 8 * 4, 4, true);
			app->input->Vibrate(0, 0.25, 150);
		}
	);


	// Shuffle palette (chars for mem optimization)
	if ((act & 0xF) != 3 && frameAnim % 4 == 0) {
		char r[4];
		char g[4];
		char b[4];
		char a[4];
		glBindTexture(GL_TEXTURE_2D, paletteDry->tex);
		for (int n = 0; n < 4; n++) {
			char x = 2;
			char y = 8 + (n + 4) % 4;
			char i = y * 4 + x;

			r[n] = paletteDry->pixels[i * 4 + 0];
			g[n] = paletteDry->pixels[i * 4 + 1];
			b[n] = paletteDry->pixels[i * 4 + 2];
			a[n] = paletteDry->pixels[i * 4 + 3];
		}
		for (int n = 0; n < 4; n++) {
			char x = 2;
			char y = 8 + (n - 1 + 4) % 4;
			char i = y * 4 + x;

			paletteDry->pixels[i * 4 + 0] = r[n];
			paletteDry->pixels[i * 4 + 1] = g[n];
			paletteDry->pixels[i * 4 + 2] = b[n];
			paletteDry->pixels[i * 4 + 3] = a[n];
		}
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, paletteDry->w,
			paletteDry->h, 0, GL_RGBA, GL_UNSIGNED_BYTE,
			paletteDry->pixels);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	for (int i = 20 - 2; i >= 0; i--) {
		inputBuffer[i * 6 + 0 + 6] = inputBuffer[i * 6 + 0];
		inputBuffer[i * 6 + 1 + 6] = inputBuffer[i * 6 + 1];
		inputBuffer[i * 6 + 2 + 6] = inputBuffer[i * 6 + 2];
		inputBuffer[i * 6 + 3 + 6] = inputBuffer[i * 6 + 3];
		inputBuffer[i * 6 + 4 + 6] = inputBuffer[i * 6 + 4];
		inputBuffer[i * 6 + 5 + 6] = inputBuffer[i * 6 + 5];
	}

	inputBuffer[0] = player->up;
	inputBuffer[1] = player->down;
	inputBuffer[2] = player->left;
	inputBuffer[3] = player->right;
	inputBuffer[4] = player->jump;
	inputBuffer[5] = player->jumpHold;

	if (playerAI != NULL) {
		playerAI->up = inputBuffer[20 * 6 - 6 + 0];
		playerAI->down = inputBuffer[20 * 6 - 6 + 1];
		playerAI->left = inputBuffer[20 * 6 - 6 + 2];
		playerAI->right = inputBuffer[20 * 6 - 6 + 3];
		playerAI->jump = inputBuffer[20 * 6 - 6 + 4];
		playerAI->jumpHold = inputBuffer[20 * 6 - 6 + 5];
	}

	// WaterLevel updating
	waterLevel = 0xD00;
	visualWaterHeight = 0xD00;

	// Wait for fade in
	if (sceneIn >= 80 && !actTransition) {
		return;
	}

	// Particle Updating
	for (unsigned int p = 0; p < part_max; p++) {
		if (particles[p] != NULL) {
			if (particles[p]->life > 0) {
				particles[p]->life--;
			}

			particles[p]->x += particles[p]->vel_x;
			particles[p]->y += particles[p]->vel_y;

			if (particles[p]->underwater) {
				if (particles[p]->y < waterLevel) {
					particles[p] = NULL;
					continue;
				}
			}

			if (particles[p]->life == 0) {
				particles[p] = NULL;
				continue;
			}
		}
	}

	// Object Updating ("me first")
	for (unsigned int o = 0; o < objects_count; o++) {
		if (objects[o] != NULL) {
			if (objects[o]->meFirst && objects[o]->active) {
				if (objects[o]->prior || (objects[o]->x - cameraX[app->CurrentViewport] >= -objects[o]->w &&
										  objects[o]->y - cameraY[app->CurrentViewport] >= -objects[o]->h &&
										  objects[o]->x - cameraX[app->CurrentViewport] < app->gameWidth + objects[o]->w &&
										  objects[o]->y - cameraY[app->CurrentViewport] < app->gameHeight + objects[o]->h)) {
				    objects[o]->update();
				}
			}
		}
	}

	// Player Update
	WITH_ALL(
		app->CurrentViewport = _______p;
		player->update();
	);

	app->CurrentViewport = 0;

	if (playerAI != NULL && player->Speed == 0) {
		float pcX = playerAI->x - cameraX[app->CurrentViewport];
		float pcY = playerAI->y - cameraY[app->CurrentViewport];
		if (pcX < -64 ||
			pcY < -64 ||
			pcX > app->gameWidth + 64 ||
			pcY > app->gameHeight + 64) {
			playerAI->x = player->x;
			playerAI->y = player->y;
			playerAI->Gravity = 0;
			playerAI->Speed = 0;
			playerAI->Action = Actions::Jumping;
		}
	}

	// Object Updating (normal)
	for (unsigned int o = 0; o < objects_count; o++) {
		if (objects[o] != NULL) {
			if (!objects[o]->meFirst && objects[o]->active) {
				if (objects[o]->prior || (objects[o]->x - cameraX[app->CurrentViewport] >= -objects[o]->w &&
										  objects[o]->y - cameraY[app->CurrentViewport] >= -objects[o]->h &&
										  objects[o]->x - cameraX[app->CurrentViewport] < app->gameWidth + objects[o]->w &&
										  objects[o]->y - cameraY[app->CurrentViewport] < app->gameHeight + objects[o]->h))
					objects[o]->update();
			}
		}
	}
	for (unsigned int o = 0; o < ringTotal; o++) {
		if (ringArr[o].Active) {
			int offY = 0;
			WITH_ALL(
				if (player->Action == Actions::Dead) continue;

				if (player->Action == Actions::Grab) {
					offY = 20;
				}
				if (player->x + 10 >= ringArr[o].X - 8 &&
					player->y + 20 + offY >= ringArr[o].Y - 8 &&
					player->x - 10 <  ringArr[o].X + 8 &&
					player->y - 20 + offY <  ringArr[o].Y + 8) {
					ringArr[o].Active = false;
					ringArr[o].Time = 16;
					getRing(1);
					aud_Ring->Play(2);
				}
				if (player->Shield == 2) {
					if ((player->x - ringArr[o].X) * (player->x - ringArr[o].X) < 64 * 64 &&
						(player->y + offY - ringArr[o].Y) * (player->y + offY - ringArr[o].Y) < 64 * 64) {
						ringArr[o].X += (player->x - ringArr[o].X) / 4;
						ringArr[o].Y += (player->y + offY - ringArr[o].Y) / 4;
					}
				}
			);
		}
		else {
			if (ringArr[o].Time > 0) {
				ringArr[o].Time--;
			}
		}
	}



	if (levelComplete && levelCompleteTimer == -1) {
		levelCompleteTimer = 10 * 60;
		maxLevelCompleteTimer = levelCompleteTimer;
	}
	if (levelComplete) {
		if (levelCompleteTimer > 0 && !app->realPaused) {
			levelCompleteTimer--;
		}
	}
}

void Scene_ICZ::DrawPrettyMuchEverything() {
	app->ChangeShader(app->shader_test);

	for (int x = 0; x < 5; x++) {
		for (int y = 0; y < levelSubH; y++) {
			int newY = y;

			if (loop)
				newY = modulo(y, levelH);

			int BGstart = 4;
			int BGsize = 5;

			int us = level[(level[newY * 4 + 10] & 0xFF) * 0x100 + (level[newY * 4 + 11] & 0xFF) - 0x8000 + ((x) % BGsize + BGstart)] & 0xFF;
			float ox = us % 16;
			float oy = us / 16;

			if (us == 0) continue;

			for (int xx = 0; xx < 16; xx++) {
				for (int yy = 0; yy < 16; yy++) {
					int CX = x * 128 - cameraX[app->CurrentViewport] + xx * 8 + 0x3180;
					int CY = y * 128 - cameraY[app->CurrentViewport] + yy * 8 + 0x100;

					int wX = ox * 16 + xx;
					int wY = oy * 16 + yy;
					int index = wX + wY * 256;
					int word = tiles[index * 3] * 0x10000 + tiles[index * 3 + 1] * 0x100 + tiles[index * 3 + 2];

					int flipTY = (word >> 17) & 0x1;
					int flipTX = (word >> 16) & 0x1;
					//int prior = (word & 0x8000) / 0x8000;
					int pal = (word & 0x6000) >> 13;
					int flipY = (word & 0x1000) / 0x1000;
					int flipX = (word & 0x800) / 0x800;
					int ind = word & 0x7FF;

					if (ind >= 690 && ind < 708) {
                        ind = 2048 + 0 + ind - 690;
                    }
                    if (ind >= 708 && ind < 724) {
                        ind = 2048 + 144 + ind - 708;
                    }
                    if (ind >= 724 && ind < 756) {
                        ind = 2048 + 400 + ind - 724;
                    }
                    if (ind >= 756 && ind < 772) {
                        ind = 2048 + 656 + ind - 756;
                    }
                    if (ind >= 772 && ind < 776) {
                        ind = 2048 + 784 + ind - 772;
                    }
                    if (ind >= 776 && ind < 808) {
                        ind = 2048 + 876 + ind - 776;
                    }
                    if (ind >= 808 && ind < 828) {
                        ind = 2048 + 796 + ind - 808;
                    }

					int tX = ind % 64;
					int tY = ind / 64;

					if (ind == 0) continue;

					if (flipTX == 1) {
						flipX = 1 - flipX;
						CX += (xx % 2 == 1 ? -8 : 8);
					}
					if (flipTY == 1) {
						flipY = 1 - flipY;
						CY += (yy % 2 == 1 ? -8 : 8);
					}

					float p = 0.75f;

					app->palette = (pal) % 4;

					if (CX + 8 < 0)
						continue;

					if (CX > app->gameWidth)
						continue;

					app->drawSpriteOPT(
						CX + flipX * 8 , CY + flipY * 8,
						8 * (flipX == 1 ? -1 : 1), 8 * (flipY == 1 ? -1 : 1),

						p,

						tX / 64.f,
						tY / 64.f,
						1.f / 64.f,
						1.f / 64.f, 46);
				}
			}
		}
	}

	int BGstart = 0;
	int BGsize = 4;

	int cameraX_BG = (int)(cameraX[app->CurrentViewport] * 7.f / 16.f);
	int cameraY_BG = (int)(cameraY[app->CurrentViewport] * 13.f / 128.f);

	// Background Chunks
	for (int y = 0; y < levelSubH; y++) {
		for (int yy = 0; yy < 16; yy++) {
			float multiplier = 1.f;
			if (y * 16 + yy < 16) {
				multiplier = 0.125f;
			}
			else if (y * 16 + yy < 23) {
				multiplier = 0.25f;
			}
			else if (y * 16 + yy < 34) {
				multiplier = 0.5f;
			}
			else {
				multiplier = 1.0f;
			}
			for (int x = cameraX_BG * multiplier / 128; x < cameraX_BG * multiplier / 128 + 5; x++) {
				int newY = y;
				int us = level[(level[newY * 4 + 10] & 0xFF) * 0x100 + (level[newY * 4 + 11] & 0xFF) - 0x8000 + ((x - BGstart) % BGsize + BGstart)] & 0xFF;
				float ox = us % 16;
				float oy = us / 16;

				if (us == 0) continue;
				for (int xx = 0; xx < 16; xx++) {
					int CX = x * 128 - cameraX_BG * multiplier + xx * 8;
					int CY = y * 128 - cameraY_BG + yy * 8;

					int wX = ox * 16 + xx;
					int wY = oy * 16 + yy;
					int index = wX + wY * 256;
					int word = tiles[index * 3] * 0x10000 + tiles[index * 3 + 1] * 0x100 + tiles[index * 3 + 2];

					int flipTY = (word >> 17) & 0x1;
					int flipTX = (word >> 16) & 0x1;
					int prior = (word & 0x8000) / 0x8000;
					int pal = (word >> 13) & 0x3;
					int flipY = (word & 0x1000) / 0x1000;
					int flipX = (word & 0x800) / 0x800;
					int ind = word & 0x7FF;

					if (ind >= 690 && ind < 708) {
                        ind = 2048 + 0 + ind - 690;
                    }
                    if (ind >= 708 && ind < 724) {
                        ind = 2048 + 144 + ind - 708;
                    }
                    if (ind >= 724 && ind < 756) {
                        ind = 2048 + 400 + ind - 724;
                    }
                    if (ind >= 756 && ind < 772) {
                        ind = 2048 + 656 + ind - 756;
                    }
                    if (ind >= 772 && ind < 776) {
                        ind = 2048 + 784 + ind - 772;
                    }
                    if (ind >= 776 && ind < 808) {
                        ind = 2048 + 876 + ind - 776;
                    }
                    if (ind >= 808 && ind < 828) {
                        ind = 2048 + 796 + ind - 808;
                    }

					int tX = ind % 64;
					int tY = ind / 64;

					if (ind == 0) continue;

					if (flipTX == 1) {
						flipX = 1 - flipX;
						CX += (xx % 2 == 1 ? -8 : 8);
					}
					if (flipTY == 1) {
						flipY = 1 - flipY;
						CY += (yy % 2 == 1 ? -8 : 8);
					}

					float p = 0.f;
					if (prior != 0)
						p = 0.8f;
					else
						p = 0.9f;

					app->palette = pal % 4;
					if (prior == 0)
						app->palette = 3;

					if (CX + 8 < 0)
						continue;

					if (CY + 8 < 0)
						continue;

					if (CX > app->gameWidth)
						continue;

					if (CY > app->gameHeight)
						continue;

					//continue;

					app->drawSpriteOPT(
						CX + flipX * 8, CY + flipY * 8,
						8 * (flipX == 1 ? -1 : 1), 8 * (flipY == 1 ? -1 : 1),

						p,

						tX / 64.f,
						tY / 64.f,
						1.f / 64.f,
						1.f / 64.f, 46);
				}
			}
		}
	}

	// Foreground Chunks
	app->palette = 0;
	for (int x = (int)(cameraX[app->CurrentViewport] / 128); x < (int)(cameraX[app->CurrentViewport] / 128) + 5; x++) {
		for (int y = (int)std::floor(cameraY[app->CurrentViewport] / 128.f); y < (int)std::floor(cameraY[app->CurrentViewport] / 128.f) + 3; y++) {
			int newY = y;

			if (loop)
				newY = modulo(y, levelH);

			int us = level[(level[8] & 0xFF) * 0x100 + (level[9] & 0xFF) - 0x8000 + x + newY * levelW] & 0xFF;
			float ox = us % 16;
			float oy = us / 16;

			if (us == 0) continue;

			for (int xx = 0; xx < 16; xx++) {
				for (int yy = 0; yy < 16; yy++) {
					int CX = x * 128 - cameraX[app->CurrentViewport] + xx * 8;
					int CY = y * 128 - cameraY[app->CurrentViewport] + yy * 8;

					int wX = ox * 16 + xx;
					int wY = oy * 16 + yy;
					int index = wX + wY * 256;
					int word = tiles[index * 3] * 0x10000 + tiles[index * 3 + 1] * 0x100 + tiles[index * 3 + 2];

					int flipTY = (word >> 17) & 0x1;
					int flipTX = (word >> 16) & 0x1;
					int prior = (word & 0x8000) / 0x8000;
					int pal = (word & 0x6000) >> 13;
					int flipY = (word & 0x1000) / 0x1000;
					int flipX = (word & 0x800) / 0x800;
					int ind = word & 0x7FF;

					if (ind >= 690 && ind < 708) {
                        ind = 2048 + 0 + ind - 690;
                    }
                    if (ind >= 708 && ind < 724) {
                        ind = 2048 + 144 + ind - 708;
                    }
                    if (ind >= 724 && ind < 756) {
                        ind = 2048 + 400 + ind - 724;
                    }
                    if (ind >= 756 && ind < 772) {
                        ind = 2048 + 656 + ind - 756;
                    }
                    if (ind >= 772 && ind < 776) {
                        ind = 2048 + 784 + ind - 772;
                    }
                    if (ind >= 776 && ind < 808) {
                        ind = 2048 + 876 + ind - 776;
                    }
                    if (ind >= 808 && ind < 828) {
                        ind = 2048 + 796 + ind - 808;
                    }

					int tX = ind % 64;
					int tY = ind / 64;

					if (ind == 0) continue;

					if (flipTX == 1) {
						flipX = 1 - flipX;
						CX += (xx % 2 == 1 ? -8 : 8);
					}
					if (flipTY == 1) {
						flipY = 1 - flipY;
						CY += (yy % 2 == 1 ? -8 : 8);
					}

					float p = 0.f;
					if (prior != 0)
						p = -0.2f;
					else
						p = 0.4f;

					app->palette = (pal) % 4;

					if (CX + 8 < 0)
						continue;

					if (CY + 8 < 0)
						continue;

					if (CX > app->gameWidth)
						continue;

					if (CY > app->gameHeight)
						continue;


					app->drawSpriteOPT(
						CX + flipX * 8 , CY + flipY * 8,
						8 * (flipX == 1 ? -1 : 1), 8 * (flipY == 1 ? -1 : 1),

						p,

						tX / 64.f,
						tY / 64.f,
						1.f / 64.f,
						1.f / 64.f, 46);
				}
			}
		}
	}
	glUniform4f(app->locData, 0, 0 / 4.f, 0, 0);
	app->renderSpriteOPT(tex_ChunksFront->tex, 46);

	app->palette = 0;

	app->drawZ = 0.45f;

    // Objects behind the Chunks
	for (unsigned int o = 0; o < objects_count; o++) {
		if (objects[o] != NULL) {
			if (objects[o]->underAll && objects[o]->active) {
				if ((objects[o]->x - cameraX[app->CurrentViewport] >= -objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] >= -objects[o]->h &&
					 objects[o]->x - cameraX[app->CurrentViewport] < app->gameWidth + objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] < app->gameHeight + objects[o]->h) || objects[o]->prior)
					objects[o]->render(cameraX[app->CurrentViewport], cameraY[app->CurrentViewport]);
			}
		}
	}

	app->drawZ = 0.3f;

	// Objects behind the Player (normal ones)
	for (unsigned int o = 0; o < objects_count; o++) {
		if (objects[o] != NULL) {
			if (objects[o]->active && !objects[o]->overAll && !objects[o]->overObj && !objects[o]->underAll) {
				if ((objects[o]->x - cameraX[app->CurrentViewport] >= -objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] >= -objects[o]->h &&
					 objects[o]->x - cameraX[app->CurrentViewport] < app->gameWidth + objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] < app->gameHeight + objects[o]->h) || objects[o]->prior)
					objects[o]->render(cameraX[app->CurrentViewport], cameraY[app->CurrentViewport]);
			}
		}
	}
	app->drawZ = 0.0f;
	// Player Renderer
	WITH_ALL(
		player->render(cameraX[app->CurrentViewport], cameraY[app->CurrentViewport]);
	);
	app->drawZ = -0.2f;

	// Objects in front of the Player
	for (unsigned int o = 0; o < objects_count; o++) {
		if (objects[o] != NULL) {
			if (objects[o]->active && objects[o]->overObj) {
				if ((objects[o]->x - cameraX[app->CurrentViewport] >= -objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] >= -objects[o]->h &&
					 objects[o]->x - cameraX[app->CurrentViewport] < app->gameWidth + objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] < app->gameHeight + objects[o]->h) || objects[o]->prior)
					objects[o]->render(cameraX[app->CurrentViewport], cameraY[app->CurrentViewport]);
			}
		}
	}

	// Ring Renderer
	//app->ChangeShader(app->shader_test);
	for (uint o = 0; o < ringTotal; o++) {
		if (ringArr[o].Active) {
			if ((ringArr[o].X - cameraX[app->CurrentViewport] >= -8 &&
				 ringArr[o].Y - cameraY[app->CurrentViewport] >= -8 &&
				 ringArr[o].X - cameraX[app->CurrentViewport] < app->gameWidth + 8 &&
				 ringArr[o].Y - cameraY[app->CurrentViewport] < app->gameHeight + 8))
				app->drawSprite(tex_Ring, ringArr[o].X - cameraX[app->CurrentViewport], ringArr[o].Y - cameraY[app->CurrentViewport], 0, (frameAnim / 8) % 4, 1.0f, 1.0f);
		}
		else {
			if (ringArr[o].Time > 0) {
				app->drawSprite(tex_Ring, ringArr[o].X - cameraX[app->CurrentViewport], ringArr[o].Y - cameraY[app->CurrentViewport], 0, (ringArr[o].Time / 6 + 4), 1.0f, 1.0f);
			}
		}
	}

	// Particle Renderer
	for (unsigned int p = 0; p < part_max; p++) {
		if (particles[p] != NULL) {
			int ind = particles[p]->max_life - particles[p]->life;
			if (ind >= 0)// && ind < particles[p]->max_life)
				app->drawSprite(particles[p]->tex, (int)particles[p]->x - cameraX[app->CurrentViewport], (int)particles[p]->y - cameraY[app->CurrentViewport], 0, std::min(ind / particles[p]->slow, particles[p]->maxFrame == 0 ? particles[p]->tex->frames : particles[p]->maxFrame), 1, 1);
		}
	}
	app->drawZ = -0.4f;

	// Front Chunk Renderer
	app->drawZ = -0.6f;

	// Objects in front of the Chunks
	for (unsigned int o = 0; o < objects_count; o++) {
		if (objects[o] != NULL) {
			if (objects[o]->active && objects[o]->overAll) {
				if ((objects[o]->x - cameraX[app->CurrentViewport] >= -objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] >= -objects[o]->h &&
					 objects[o]->x - cameraX[app->CurrentViewport] < app->gameWidth + objects[o]->w &&
					 objects[o]->y - cameraY[app->CurrentViewport] < app->gameHeight + objects[o]->h) || objects[o]->prior)
					objects[o]->render(cameraX[app->CurrentViewport], cameraY[app->CurrentViewport]);
			}
		}
	}
	app->ChangeShader(app->shader_basic);
	app->drawZ = -0.8f;
}

// UNIQUE
void Scene_ICZ::BackgroundParallaxRender() {
	float scaleY = (frontHorizonChunkHeight - 1.75f / 2.f) / (backHorizonChunkHeight - 1.75f / 2.f);

	int shortY = (int)(-cameraY[app->CurrentViewport] / scaleY);// = (int)(y / 128 * 128 - cameraY[app->CurrentViewport] / scaleY) + (y % 128);

	// Draw Third Layer Parallax
	int y = 0;
	int anim[64];
	int anim2[64];
	for (int l = 0; l < 64; l++) {
		anim[l] = -1;
		anim2[l] = -1;
	}
	int lastHeight = 0;
	for (int lay = 0; lay < layerCount; lay++) {
		shortY += lastHeight;

		int shortX = floor((-cameraX[app->CurrentViewport] * layers[lay].Per / 4) + (int)(cameraX[app->CurrentViewport] * layers[lay].Per / 4 / (levelSubW * 128)) * (levelSubW * 128));

		if (shortY + layers[lay].Height > 0 && shortY < app->gameHeight) {
			for (int x = 0; x < levelSubW * 2; x++) {
				if (shortX + 256 <= 0 || shortX - 128 >= app->gameWidth) {
					shortX += 128;
					continue;
				}


				int us = level[(level[y / 128 * 4 + 10] & 0xFF) * 0x100 + (level[y / 128 * 4 + 11] & 0xFF) - 0x8000 + (x % levelSubW)] & 0xFF;
				int a = animChunks[us];
				if (a >= 0) {
					int type = ((animType[a] & 0xF0) / 0x10);
					if (type == 2) {
						int frames = ((animType[a] & 0xF00) / 0x100);
						int frm = (int)(-cameraX[app->CurrentViewport] / frames) % 128;
						if (us != 0xCB) {
							app->drawSpriteOPT(
								shortX + frm - 64 + 128, shortY - 16,
								128, layers[lay].Height,

								0.901f,

								0,
								(mod(y, 128) / 128.0f) * 0.5f,
								1.f / frames,
								0.5f * layers[lay].Height / 128.0f, 64 - layerCount * 2 + lay);

							app->drawSpriteOPT(
								shortX + frm - 00 + 128, shortY - 16,
								128, layers[lay].Height,

								0.901f,

								0,
								(mod(y, 128) / 128.0f) * 0.5f,
								1.f / frames,
								0.5f * layers[lay].Height / 128.0f, 64 - layerCount * 2 + lay);



							/*float sx = frm / frames;
							float sw = (frm + 1) / frames;

							float sy = (mod(y, 128) / 128.0f) * 0.5f;
							float sh = sy + 0.5f * layers[lay].Height / 128.0f;

							GLfloat texelData[] = {
								sx, sh,
								sw, sh,
								sw, sy,
								sx, sy
							};*/



							/*app->drawSpriteOPT(animTex[a], shortX + 128 + frm - 00, shortY - 16, 128, layers[lay].Height,
												0,
												(mod(y, 128) / 128.0f) * 0.5f,
												1.f / frames,
												0.5f * layers[lay].Height / 128.0f, lay + 0x00064);*/
						}

						/*app->drawSpriteT(animTex[a]->tex, TBOs[(x % levelSubW) * layerCount * 8 + lay * 8 + 0],
							shortX + frm - 64, shortY,
							0, 0,
							128, layers[lay].Height,
							0);

						app->drawSpriteT(animTex[a]->tex, TBOs[(x % levelSubW) * layerCount * 8 + lay * 8 + 0],
							shortX + frm - 00, shortY,
							0, 0,
							128, layers[lay].Height,
							0);*/

						if (anim2[lay] < 0) {
							anim2[lay] = animTex[a]->tex;
						}

						app->drawSpriteOPT(
							shortX + frm - 64, shortY,
							128, layers[lay].Height,

							0.901f,

							0,
							(mod(y, 128) / 128.0f) * 0.5f,
							1.f / frames,
							0.5f * layers[lay].Height / 128.0f, 64 - layerCount * 2 + lay);

						app->drawSpriteOPT(
							shortX + frm - 00, shortY,
							128, layers[lay].Height,

							0.901f,

							0,
							(mod(y, 128) / 128.0f) * 0.5f,
							1.f / frames,
							0.5f * layers[lay].Height / 128.0f, 64 - layerCount * 2 + lay);

						/*app->drawTextureTopR(animTex[a], shortX + frm - 64, shortY, 128, layers[lay].Height,
											0,
											(mod(y, 128) / 128.0f) * 0.5f,
											1.f / frames,
											0.5f * layers[lay].Height / 128.0f, lay + 0x00128);
						app->drawTextureTopR(animTex[a], shortX + frm - 00, shortY, 128, layers[lay].Height,
											0,
											(mod(y, 128) / 128.0f) * 0.5f,
											1.f / frames,
											0.5f * layers[lay].Height / 128.0f, lay + 0x00192);*/
					}
				}

				shortX += 128;
			}
		}
		y += layers[lay].Height;
		lastHeight = layers[lay].Height;
	}


	// Normal Parallax
	for (int x = 0; x < levelSubW * 2; x++) {
		int y = 0;
		for (int lay = 0; lay < layerCount; lay++) {
			int us = level[(level[y / 128 * 4 + 10] & 0xFF) * 0x100 + (level[y / 128 * 4 + 11] & 0xFF) - 0x8000 + (x % levelSubW)] & 0xFF;

			int shortY = (int)(y / 128) * 128.f - cameraY[app->CurrentViewport] / scaleY + (y % 128);

			if (shortY + layers[lay].Height > 0 && shortY < app->gameHeight) {
				// save on calculation time
				int shortX = floor((-cameraX[app->CurrentViewport] * layers[lay].Per) + (int)(cameraX[app->CurrentViewport] * layers[lay].Per / (levelSubW * 128)) * (levelSubW * 128)) + floor(x * 128);

				int a = animChunks[us];
				if (a >= 0) {
					int frames = ((animType[a] & 0xF00) / 0x100);
					int type = ((animType[a] & 0xF0) / 0x10);
					int speed = animType[a] & 0xF;
					int frm = (frameAnim / speed) % frames;
					if (type == 1) {
						//frm = zigzag(frame / speed, frames);
					}
					else if (type == 2) {
						frm = (int)(-cameraX[app->CurrentViewport] / frames) % 128;
					}


					if (anim[lay] < 0) {
						anim[lay] = animTex[a]->tex;
					}
					if (type != 2) {
						app->drawSpriteOPT(
							shortX, shortY,
							128, layers[lay].Height,

							0.9f,

							frm * 1.f / frames,
							(mod(y, 128) / 128.0f) * 0.5f + 0.5f,
							1.f / frames,
							0.5f * layers[lay].Height / 128.0f, 64 - layerCount + lay);
					}
					else {
						app->drawSpriteOPT(
							shortX, shortY,
							128, layers[lay].Height,

							0.9f,

							0,
							(mod(y, 128) / 128.0f) * 0.5f + 0.5f,
							1.f / frames,
							0.5f * layers[lay].Height / 128.0f, 64 - layerCount + lay);
					}
				}
				else {
					if (anim[lay] < 0) {
						anim[lay] = tex_ChunksBack->tex;
					}

					app->drawSpriteOPT(
						shortX, shortY,
						128, layers[lay].Height,

						0.9f,

						(us % 16) * 0.0625f,
						(us / 16 + mod(y, 128) / 128.0f) * 0.0625f,
						0.0625f,
						layers[lay].Height / 128.0f / 16.0f, 64 - layerCount + lay);
				}
			}
			y += layers[lay].Height;
		}
	}


	for (int i = 0; i < layerCount; i++) {
		if (anim[i] > 0) {
			app->renderSpriteOPT(anim[i], 64 - layerCount + i);
		}
		if (anim2[i] > 0) {
			app->renderSpriteOPT(anim2[i], 64 - layerCount * 2 + i);
		}
	}
}

// OVERRIDES
void Scene_ICZ::HandleCamera() {
	LevelScene::HandleCamera();

	if (cameraPlayer->Action == Actions::Dead)
		return;

	/*if ((act & 0xF) == 1) {
		if (player->x > 0x35B0) {
			cameraMinX = cameraX[app->CurrentViewport];
			cameraMinY = cameraY[app->CurrentViewport];

			cameraMaxX = (float)(levelW * 128 - 24 - app->gameWidth);
			cameraMaxY = (float)(0x0710 - app->gameHeight);
		}
	}
	else {
		cameraMaxX = (float)(levelW * 128 - 24 - app->gameWidth);
		cameraMaxY = (float)(levelH * 128 - app->gameHeight);
	}*/
}
void Scene_ICZ::DoPaletteWaterStuff() {
	LevelScene::DoPaletteWaterStuff();
}
void Scene_ICZ::DoBackgroundStuff() {
	LevelScene::DoBackgroundStuff();

	// Background and Parallax Rendering
	app->drawZ = 0.6f;

	// ICZ Waterline Rendering
	app->drawZ = 0.4f;
}
void Scene_ICZ::DrawAboveEverythingNonHUD() {
	LevelScene::DrawAboveEverythingNonHUD();

	int waveOff = (int)std::sin(frameAnim / 360.0f * Math_PI) * 10;
	cameraX[app->CurrentViewport] += waveOff;
	int waveFr = (frameAnim / 10) % 3;
	if ((act & 0xF) == 1) {
		for (unsigned int o = 0; o < 3; o++) {
			app->drawSpriteOPT(
				256 * o + ((int)(cameraX[app->CurrentViewport]) / 256) * 256 + (0) * 32 - cameraX[app->CurrentViewport], waterLevel - 16 - cameraY[app->CurrentViewport],
				256, 24,

				app->drawZ,

				waveFr / 3.0f, 0, 1 / 3.0f, 1,

				2);
			app->drawSpriteOPT(
				256 * o + ((int)(cameraX[app->CurrentViewport]) / 256) * 256 + (1) * 32 - cameraX[app->CurrentViewport], waterLevel - 16 - cameraY[app->CurrentViewport],
				256, 24,

				app->drawZ,

				waveFr / 3.0f, 0, 1 / 3.0f, 1,

				2);
		}
	}
	else {
		for (unsigned int o = 0; o < 3; o++) {
			app->drawSpriteOPT(
				256 * o + ((int)(cameraX[app->CurrentViewport]) / 256) * 256 + (0) * 32 - cameraX[app->CurrentViewport], visualWaterHeight - 16 - cameraY[app->CurrentViewport],
				256, 24,

				app->drawZ,

				waveFr / 3.0f, 0, 1 / 3.0f, 1,

				2);
			app->drawSpriteOPT(
				256 * o + ((int)(cameraX[app->CurrentViewport]) / 256) * 256 + (1) * 32 - cameraX[app->CurrentViewport], visualWaterHeight - 16 - cameraY[app->CurrentViewport],
				256, 24,

				app->drawZ,

				waveFr / 3.0f, 0, 1 / 3.0f, 1,

				2);
		}
	}
	app->renderSpriteOPT(tex_Waves->tex, 2);
	cameraX[app->CurrentViewport] -= waveOff;
}
void Scene_ICZ::Render() {
	LevelScene::Render();
}
void Scene_ICZ::Free() {
	LevelScene::Free();
	UnloadUniqueTextures(app, 1);
	UnloadUniqueTextures(app, 2);
	unloadAnimatedChunks(app);
}
