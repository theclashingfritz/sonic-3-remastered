#if __VERSION__ < 110
precision mediump float;
#endif
uniform vec2 rubyInputSize;
uniform vec2 rubyOutputSize;
uniform vec2 rubyTextureSize;

uniform vec3 u_translate;
uniform vec3 u_scale;
uniform float u_rotate;

#if __VERSION__ >= 130
    in vec3 v_position;
    in vec2 v_texcoord;
    out vec2 _texcoord;
    out vec2 _one;
    out float _mod_factor;
#else
    attribute vec3 v_position;
    attribute vec2 v_texcoord;
    varying vec2 _texcoord;
    varying vec2 _one;
    varying float _mod_factor;
#endif

mat4 scale(vec3 s) {
    return mat4(
        vec4(s.x, 0.0, 0.0, 0.0),
        vec4(0.0, s.y, 0.0, 0.0),
        vec4(0.0, 0.0, s.z, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    ); }
mat4 translate(vec3 t) {
    return mat4(
        vec4(1.0, 0.0, 0.0, 0.0),
        vec4(0.0, 1.0, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(t.x, t.y, t.z, 1.0)
    ); }
mat4 rotate_z(float theta) {
    theta = radians(theta);
    return mat4(
        vec4( cos(theta),  sin(theta), 0.0, 0.0),
        vec4(-sin(theta),  cos(theta), 0.0, 0.0),
        vec4(0.0,         0.0,         1.0, 0.0),
        vec4(0.0,         0.0,         0.0, 1.0)
    ); }

void main() {
    float left = 0.0;
    float right = 400.0;
    float bottom = 225.0;
    float top = 0.0;

    mat4 projection = mat4(
        vec4(2.0 / (right - left), 0, 0, 0),
        vec4(0, 2.0 / (top - bottom), 0, 0),
        vec4(0, 0, 1, 0),
        vec4(-1, 1, 0, 1)
    );

    gl_Position = projection *
        translate(u_translate) *
        rotate_z(u_rotate) *
        scale(u_scale) *
        vec4(v_position, 1.0);

    _texcoord = v_texcoord;
    _one = 1.0 / rubyTextureSize;
    _mod_factor = _texcoord.x * rubyTextureSize.x * rubyOutputSize.x / rubyInputSize.x;
}
